package com.github.mrmks.status;

import com.github.mrmks.status.adapt.IDataAccessor;
import com.github.mrmks.status.adapt.IEntityConvert;
import com.github.mrmks.status.adapt.IEntityDataAccessor;
import com.github.mrmks.status.adapt.ILogger;
import com.github.mrmks.status.adapt.data.StorePair;
import com.github.mrmks.status.adapt.data.ValuePair;
import com.github.mrmks.status.api.WritingStatus;
import com.github.mrmks.utils.*;

import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * The T is the entity instance of your game, but we don't obtain your instance here directly,
 * we use the byte[] for instead, which is also the key when we store the data;
 */
class EntityManager<T> {

    private final TaskManager taskManager;
    private final IDataAccessor dataAccessor;
    private final IEntityConvert<T> convert;
    private final StateControl sessionControl;
    private final ILogger logger;

    private final WrappedAttribute<T>[] attributes;
    private final StringIntMap attributeConvertMap;
    private final WrappedAttributeProvider<T>[] providers;
    private final int resourceSize;
    private final int resourceSize2;

    private final IntQueue refreshedAry;
    private int nextIndex;
    private final ByteArrayToIntMap indexConvert;
    private StatusEntity[] entityMap;

    private final IntQueue removingQueue;

    private final int[][] taskResourceAry;
    private final int[] taskIntervals;
    private final int[] baseValues;
    private final boolean[] autoStepZero;

    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    private final ExecutorService executor = Executors.newSingleThreadExecutor();

    private final IntArray cacheIds = new IntArray(64), cacheVs = new IntArray(64);

    EntityManager(
            TaskManager taskManager,
            IEntityConvert<T> iec,
            IDataAccessor ida,
            ILogger logger,
            StateControl sessionControl,
            WrappedAttribute<T>[] attributeAry,
            int resourceSize,
            int[] taskIntervals,
            int[][] taskResourceAry,
            int[] baseValues,
            boolean[] autoStepZero,
            WrappedAttributeProvider<T>[] attributeProviderAry
    ) {
        this.dataAccessor = ida;
        this.convert = iec;
        this.logger = logger;
        this.sessionControl = sessionControl;
        this.taskManager = taskManager;
        this.attributes = attributeAry;
        this.resourceSize = resourceSize;
        this.resourceSize2 = resourceSize << 1;
        this.taskIntervals = taskIntervals;
        this.baseValues = baseValues;
        this.autoStepZero = autoStepZero;
        this.taskResourceAry = taskResourceAry;

        this.providers = attributeProviderAry;

        this.entityMap = new StatusEntity[1024];
        this.indexConvert = new ByteArrayToIntMap(1024);
        this.refreshedAry = new IntQueue(64);
        this.nextIndex = 1;

        this.removingQueue = new IntQueue();
        this.attributeConvertMap = null;

        byte[] sysBytes = new byte[0];
        entityMap[0] = new StatusEntity(sysBytes, null, null, false, 0, null);
    }

    int queryAttribute(String key) {
        return CommonUtils.binarySearch(attributes, o -> o.name, key, String::compareTo);
    }

    /*
     * This method either create a new StatusEntity for the given entity or resume an offline entity
     * The shouldSave argument will be ignored when resume the offline entity.
     *
     * todo: load data in executor thread
     */
    void createEntity(T entity, boolean shouldSave) {

        // you can't create entity in session.
        if (sessionControl.shouldDenyEntityModify()) throw new IllegalStateException();

        byte[] bytes = convert.toBytes(entity);
        if (bytes == null || bytes.length == 0) throw new RuntimeException("Null or empty byte array shouldn't be generated by IEntityConvert");
        int index = findEntityIndex(bytes);
        // entity existed
        if (index >= 0) {
            StatusEntity se = entityMap[index];
            resumeEntity(entity, se);
        } else {

            IEntityDataAccessor da;
            try {
                da = dataAccessor.withEntity(bytes);
            } catch (IOException e) {
                throw new RuntimeException("Exception while creating DataAccessor with entity(" + Arrays.toString(bytes) + ") for read", e);
            }
            if (da == null) throw new RuntimeException("Null generated while creating DataAccessor with(" + Arrays.toString(bytes) + ") for read");

            index = refreshedAry.isEmpty() ? nextIndex++ : refreshedAry.remove();
            indexConvert.put(bytes, index);

            StatusTable table = new StatusTable(attributes.length);
            WritingImpl ws = new WritingImpl(resourceSize, attributes.length, cacheIds, cacheVs);
            for (WrappedAttributeProvider<T> wap : providers) {
                wap.update(entity, ws);
                for (int i = 0; i < ws.length; i++) table.accept(ws.ids.at(i), ws.vs.at(i));
                ws.reset();
            }


            for (int i = 0; i < resourceSize; i++) {
                int val = shouldSave ? da.getValue(i).orElse(0) : 0;
                table.accept(i, val + baseValues[i]);
                table.accept(i + resourceSize, baseValues[i + resourceSize]);
                table.accept((resourceSize << 1) + i, baseValues[i + resourceSize2]);
            }

            // create resource task;
            ResourceTask task = new ResourceTask(index);
            taskManager.addTask(task);

            int[][] storedData = shouldSave ? da.getStore() : null;

            StatusEntity se = new StatusEntity(bytes, table, storedData, shouldSave, index, task);
            if (index >= entityMap.length) {
                entityMap = Arrays.copyOf(entityMap, index << 1);
            }
            entityMap[index] = se;
        }
    }

    private void resumeEntity(T entity, StatusEntity se) {
        if (entity != null && se != null && se.offline) {
            se.offline = false;
            int v;
            for (int i = 0; i < resourceSize; i++) {
                v = se.table.get(i);
                attributes[i].update(entity, v, v);
            }
        }
    }

    void removeEntity(T entity) {

        // also, you can't remove entity in session.
        if (sessionControl.shouldDenyEntityModify()) throw new IllegalStateException();

        int index = findEntityIndex(entity);
        if (index > 0) removeEntity(index);
    }

    private void removeEntity(int index) {
        StatusEntity se = getEntity(index);
        if (se != null) removeEntity(se);
    }

    private boolean removeEntity(StatusEntity se) {
        if (se.id == 0) throw new RuntimeException("Can't remove system entity");
        if (se.buffRefCount > 0) {
            if (!se.offline) {
                se.offline = true;
                if (!se.shouldSave) {
                    se.resourceTask.cancel(true);
                }
            }
            return false;
        } else {
            se.offline = true;
            return removeEntity0(se);
        }
    }

    private boolean removeEntity0(StatusEntity se) {
        if (se.id == 0) throw new RuntimeException("Can't remove system entity");
        if (se.shouldSave) {
            StatusTable table = se.table;
            IEntityDataAccessor da;
            try {
                da = dataAccessor.withEntity(se.storeKey);
            } catch (IOException e) {
                logger.severe("Exception while creating DataAccessor with entity(" + Arrays.toString(se.storeKey) + ") for write", e);
                return false;
            }
            if (da == null) {
                logger.severe("Null generated while creating DataAccessor with(" + Arrays.toString(se.storeKey) + ") for write");
                return false;
            }

            int[] val = new int[resourceSize];
            table.copy(val);
            for (int i = 0; i < resourceSize; i++) val[i] -= baseValues[i];

            try {
                da.writeValue(val);
                da.writeStore(se.data);
            } catch (IOException e) {
                logger.severe("Can't save data for entity(" + Arrays.toString(se.storeKey) + "), we will try again later", e);
                return false;
            }
            try {
                da.flushAndClose();
            } catch (IOException e) {
                logger.severe("Can't save date for entity(" + Arrays.toString(se.storeKey) + "), we will try again later", e);
                return false;
            }
            se.resourceTask.cancel(true);
        }
        if (se.id + 1 == nextIndex) --nextIndex; else refreshedAry.offer(se.id);
        return true;
    }

    void stopAll() {
        int[] val = new int[resourceSize];
        // since entityMap[0] is the system entity, we start at 1;
        for (int i = 1; i < nextIndex; i++) {
            StatusEntity se = entityMap[i];
            if (se != null) {
                se.resourceTask.cancel(true);
                se.offline = true;
                if (se.shouldSave) {
                    StatusTable table = se.table;
                    table.copy(val);
                    for (int j = 0; j < resourceSize; ++j) val[j] -= baseValues[j];
                    IEntityDataAccessor da;
                    try {
                        da = dataAccessor.withEntity(se.storeKey);
                    } catch (IOException e) {
                        logger.severe("Can't create DataAccessor with entity(" + Arrays.toString(se.storeKey) + ")", e);
                        continue;
                    }
                    if (da == null) {
                        logger.severe("Can't create DataAccessor with entity(" + Arrays.toString(se.storeKey) + "), null DataAccessor generated");
                        continue;
                    }
                    try {
                        da.writeValue(val);
                        da.writeStore(se.data);
                    } catch (IOException e) {
                        logger.severe("Can't save data with entity(" + Arrays.toString(se.storeKey) + ")", e);
                    }
                    try {
                        da.flushAndClose();
                    } catch (IOException e) {
                        logger.severe("Can't save data with entity(" + Arrays.toString(se.storeKey) + ")", e);
                    }
                }
            }
        }
        try {
            dataAccessor.flushAll();
        } catch (IOException e){
            logger.severe("Exception while flushing DataAccessor", e);
        }
    }

    void reduceEntityRef(int id) {
        if (id == 0) return;
        StatusEntity se = getEntity(id);
        if (se != null && se.buffRefCount > 0) {
            --se.buffRefCount;
            if (se.buffRefCount == 0 && se.offline) {
                removingQueue.offer(id);
            }
        }
    }

    boolean testEntity(T entity, int id) {
        StatusEntity se = getEntity(id);
        return id == 0 || se != null && Arrays.equals(se.storeKey, convert.toBytes(entity));
    }

    int findEntityIndex(T entity) {
        if (entity == null) return -1;
        byte[] bytes = convert.toBytes(entity);
        if (bytes == null || bytes.length == 0) throw new IllegalStateException("Your IEntityConvert implementation returned a null or empty byte array, which is prohibited");
        return indexConvert.getOrDefault(bytes, -1);
    }

    private int findEntityIndex(byte[] bytes) {
        return bytes == null ? -1 : indexConvert.getOrDefault(bytes, -1);
    }

    StatusEntity getEntity(int id) {
        return id >= 0 && id < entityMap.length ? entityMap[id] : null;
    }

    StatusEntity getEntity0(int id) {
        return entityMap[id];
    }

    private void applyResourceStep(int index, IntQueue queue) {
        if (queue == null || queue.isEmpty()) return;
        StatusEntity se = getEntity(index);
        if (se == null) return;

        if (!se.offline || se.shouldSave) {
            T entity = null;
            boolean f = false;
            if (!se.offline) {
                entity = convert.fromBytes(se.storeKey);
                f = entity == null && removeEntity(se);
            }
            if (f) return;
            StatusTable table = se.table;
            do {
                int i = queue.remove();
                int[] ary = new int[taskResourceAry[i].length];
                for (int id : taskResourceAry[i]) {
                    ary[i] = table.get(id + resourceSize2);
                }
                applyResource0(se, entity, taskResourceAry[i], ary, true);
            } while (!queue.isEmpty());
        }
    }

    void applyResource(T entity, int index, int[] id, int[] val) {
        if (id == null || val == null || id.length != val.length || id.length == 0) return;
        StatusEntity se = getEntity(index);
        if (se == null) return;

        applyResource0(se, entity, id, val, false);
    }

    private void applyResource0(StatusEntity se, T entity, int[] id, int[] val, boolean step) {
        if (se.id == 0) return;
        boolean direct = !se.offline && entity != null && Arrays.equals(convert.toBytes(entity), se.storeKey);
        StatusTable table = se.table;

        int _id, _val, _mod;
        for (int i = 0; i < id.length; ++i) {
            _id = id[i];
            _mod = val[i];

            if (_id < 0 || _id >= resourceSize || _mod == 0) continue;

            _val = table.get(_id);
            if (step && _val == 0 && !autoStepZero[_id]) continue;

            if (_mod > 0) {
                _mod = Math.min(table.get(_id + resourceSize) - _val, _mod);
            } else {
                _mod = Math.max(-_val, _mod);
            }
            if (_mod == 0) continue;

            _mod += _val;
            table.set(_id, _mod);
            if (direct) attributes[_id].update(entity, _val, _mod);
        }
    }

    void applyAttribute(T entity, int eid, int[] id, int[] val) {
        if (id == null || val == null || id.length != val.length || id.length == 0 || eid == 0) return;
        StatusEntity se = getEntity(eid);
        if (se == null) return;
        entity = entity == null ? convert.fromBytes(se.storeKey) : entity;
        boolean directUpdate = !se.offline && entity != null;
        int _id, _val, _prev, _r_id, _r_val, _r_prev;
        for (int i = 0; i < id.length; ++i) {
            _id = id[i];
            _val = val[i];
            if (_id < resourceSize || _id >= attributes.length || _val == 0) continue;

            _prev = se.table.accept(_id, _val);
            if (_id < resourceSize2 && _val < 0 && (_r_val = _prev + _val - se.table.get(_r_id = _id - resourceSize)) < 0) {
                _r_prev = se.table.accept(_r_id, _r_val);
                if (directUpdate) attributes[_r_id].update(entity, _r_prev, _r_val);
            }
            if (directUpdate) attributes[_id].update(entity, _prev, _val);
        }
    }

    int checkIdAndVal(int[] id, int[] val, boolean attr) {
        if (id == null || val == null || id.length != val.length) return 0;
        else {
            int _id, _val, j = id.length;
            boolean f;
            for (int i = 0; i < j; i++) {
                _id = id[i]; _val = val[i];
                if (_val == 0 || _id < 0 || _id >= attributes.length || attr == _id < resourceSize) {
                    f = true;
                    while (j > i + 1) {
                        --j;
                        _id = id[j]; _val = val[j];
                        if (_val != 0 && _id >= 0 && _id < attributes.length && attr == _id >= resourceSize) {
                            id[i] = _id;
                            val[i] = _val;
                            f = false;
                            break;
                        }
                    }
                    if (f) return i;
                }
            }
            return j;
        }
    }

    int updateProvider(T entity, String key) {
        int id = CommonUtils.binarySearch(providers, obj -> obj.name, key, String::compareTo);
        if (id >= 0) {
            updateProvider(entity, id);
        }
        return id;
    }

    void updateProvider(T e, int id) {
        if (!sessionControl.shouldDenyEntityModify() && id >= 0 && id < providers.length) {
            int index = findEntityIndex(e);
            StatusEntity se = getEntity(index);
            if (se == null) return;

            if (se.offline) resumeEntity(e, se);

            WrappedAttributeProvider<T> wap = providers[id];
            WritingImpl ws = new WritingImpl(resourceSize, attributes.length, cacheIds, cacheVs);
            wap.update(e, ws);
            for (int i = 0; i < ws.length; i++) se.table.accept(ws.ids.at(i), ws.vs.at(i));
        }
    }

    StatusTable.Readonly createReadonly(int index) {
        if (index == 0) return null;
        StatusEntity se = getEntity(index);
        if (se != null) {
            return se.table.readonly();
        } else {
            return null;
        }
    }

    int[] getModifierStore(int index, int storeId) {
        StatusEntity se = entityMap[index];
        int[] re = Constants.EMPTY_ARY_INT;
        if (se != null) {
            re = se.getData(storeId);
        }
        return re;
    }

    byte[] getEntityKey(int index) {
        StatusEntity se = getEntity(index);
        return se == null ? null : se.storeKey;
    }

    boolean isResourceId(int id) {
        return id >= 0 && id < resourceSize;
    }

    boolean isAttributeId(int id) {
        return id >= resourceSize && id < attributes.length;
    }

    void tick() {
        int size = removingQueue.size();
        for (int i = 0; i < size; ++i) {
            int j = removingQueue.remove();
            if (j == 0) continue;
            StatusEntity se = getEntity(j);
            if (se != null && !removeEntity(se)) {
                removingQueue.offer(j);
            }
        }
    }

    private static class WritingImpl implements WritingStatus {

        private final int size;
        private final int begin;
        private final IntArray ids, vs;
        private int length = 0;
        private WritingImpl(int resourceSize, int dataSize, IntArray ids, IntArray vs) {
            this.begin = resourceSize;
            this.size = dataSize;
            this.ids = ids;
            this.vs = vs;
        }

        @Override
        public void write(int id, int val) {
            if (id < begin || id >= size || id > Short.MAX_VALUE || val == 0) return;
            int index = ids.indexOf(id, length);
            if (index < 0) {
                (ids.size() == length ? ids.enlarge(length) : ids).set(length, id);
                (vs.size() == length ? vs.enlarge(length) : vs).set(length, val);
                length ++;
            } else {
                vs.set(index, vs.at(index) + val);
            }
        }

        private void reset() {
            length = 0;
        }
    }

    private class ResourceTask extends TaskManager.Task {
        private final int eid;
        private final int[] remainingTicks = Arrays.copyOf(taskIntervals, taskIntervals.length);

        private ResourceTask(int id) {
            this.eid = id;
        }

        @Override
        public int run(int it, boolean reset) {
            StatusEntity se = entityMap[eid];
            if (se == null) {
                cancel(true);
                return -1;
            }

            int re = Integer.MAX_VALUE;
            IntQueue queue = new IntQueue();
            for (int i = 0; i < remainingTicks.length; i++) {
                remainingTicks[i] -= it + 1;
                if (remainingTicks[i] < 0) {
                    remainingTicks[i] = taskIntervals[i];
                    queue.offer(i);
                }
                re = Math.min(re, remainingTicks[i]);
            }
            applyResourceStep(eid, queue);
            return re;
        }
    }

    private class EntityDataLoadRunner implements Runnable {

        private int target;
        private StatusEntity se;

        private EntityDataLoadRunner(int i, StatusEntity se) {
            target = i;
            this.se = se;
        }

        @Override
        public void run() {
            try {
                while (!lock.readLock().tryLock(50, TimeUnit.MILLISECONDS));
            } catch (InterruptedException e) {
                return;
            }
            {
                StatusEntity _se = entityMap[target];
                if (_se == null || _se != se) return;
            }
            lock.readLock().unlock();

            IEntityDataAccessor dea;
            try {
                dea = dataAccessor.withEntity(se.storeKey);
                if (dea == null) throw new BrokenImplementationException();
            } catch (IOException | BrokenImplementationException e) {
                logger.severe("Unable to load data for entity: " + convert.familiarName(se.storeKey), e);
                return;
            }

            ValuePair[] vps;
            try {
                vps = dea.readValue();
            } catch (IOException e) {
                logger.severe("Unable to load data for entity: " + convert.familiarName(se.storeKey), e);
                vps = null;
            }
            if (vps != null) {
                StatusTable st = se.table;
                for (ValuePair vp : vps) {
                    if (vp != null) {
                        int id = attributeConvertMap.getOrDefault(vp.getKey(), -1);
                        st.accept(id, vp.getValue());
                    }
                }
            }

            StorePair[] sps;
            try {
                sps = dea.readStore();
            } catch (IOException e) {
                logger.severe("Unable to load stored modifier data for entity: " + convert.familiarName(se.storeKey), e);
                sps = null;
            }
            if (sps != null) {
            }
        }
    }
}
